<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<title>webmemofmt</title>
</head><body>

<main>
<div class=divleft>
<h1><a href=https://github.com/code4fukui/webmemo/ target=_blank>webmemofmt</a></h1>
<input type=text id=infilter placeholder=filter>
<button id=btnnew>+ new memo</button>
<div id=divlist></div>
</div>
<div id=diveditor></div>
</main>

<style>
body {
  margin: 0;
  height: 100vh;
  font-family: sans-serif;
  box-sizing: border-box;
}
main {
  display: grid;
  grid-template-columns: 8em auto;
  height: 100%;
}
.divleft {
  background-color: #222;
  color: #eee;
  padding: .2em;
  font-size: small;
}
h1 {
  font-size: medium;
  padding: 0;
  text-align: left;
  margin: 0;
}
h1 a {
  text-decoration: none;
  color: #eee !important;
}
.divleft input {
  width: 90%;
  margin: 0.3em 0;
}
#divlist {
  overflow: hidden;
  white-space: nowrap;
  padding: .5em 0;
  line-height: 1.3;
}
#diveditor {
  background-color: #222;
  padding: .3em;
  color: white;
}
</style>
</body>

<script type="module">
import { DateTime } from "https://js.sabae.cc/DateTime.js";
import { cr } from "https://js.sabae.cc/cr.js";
import { IndexedStorage } from "https://code4fukui.github.io/IndexedStorage/IndexedStorage.js";

const dbname = "webmemofmt1";
const storage = await IndexedStorage.create(dbname, 1);

const memos = JSON.parse(await storage.getItem("memos") || "{}");
const saveMemo = async () => {
  await storage.setItem("memos", JSON.stringify(memos));
};

let currentmemo = null;

const fmt = [
  {
    name: "記録者",
    type: "string",
  },
  {
    name: "血圧(BP)",
    type: "number",
  },
  {
    name: "脈拍(P)",
    type: "number",
  },
  {
    name: "酸素飽和度(SpO2)",
    type: "number",
  },
  {
    name: "体温(T)",
    type: "number",
  },
  {
    name: "起きたこと",
    type: "text",
  },
  {
    name: "対応したこと",
    type: "text",
  },
  {
    name: "記録日時",
    type: "datetime",
  },
  {
    name: "記録場所",
    type: "gps",
  },
];

let latlng = "";

let gpscallback = null;
let watchid = null;
const startGPS = (callback) => {
  gpscallback = callback;
  if (!navigator.geolocation) {
    alert("このブラウザーは位置情報に対応していません");
    gpscallback(null);
    return;
  }
  if (watchid) {
    navigator.geolocation.clearWatch(watchid);
  }
  watchid = navigator.geolocation.watchPosition(
    (position) => {
      // success
      const lat = position.coords.latitude;
      const lng = position.coords.longitude;
      latlng = lat.toFixed(6) + "," + lng.toFixed(6);
      gpscallback(latlng);
    },
    () => {
      alert("GPS測位失敗！");
      gpscallback(null);
    },
    {
  		enableHighAccuracy: true, // 高精度を要求する
      timeout: 60 * 1000, // 最大待ち時間（ミリ秒） 60sec
      maximumAge: 10 * 1000, // キャッシュ有効期間（ミリ秒） 10sec
    },
  );
};

const makeFormated = (fmt) => {
  const tbl = document.createElement("div");
  tbl.style.display = "grid";
  tbl.style.gridTemplateColumns = "auto 1f";
  const comps = {};
  for (const f of fmt) {
    const divname = document.createElement("div");
    divname.textContent = f.name;
    tbl.appendChild(divname);
    if (f.type == "number") {
      const inp = document.createElement("input");
      inp.type = "number";
      inp.style.fontSize = "18px";
      tbl.appendChild(inp);
      comps[f.name] = inp;
    } else if (f.type == "text") {
      const ta = document.createElement("textarea");
      ta.style.height = "5em";
      ta.style.fontSize = "18px";
      tbl.appendChild(ta);
      comps[f.name] = ta;
    } else if (f.type == "string") {
      const inp = document.createElement("input");
      inp.type = "text";
      inp.style.fontSize = "18px";
      tbl.appendChild(inp);
      comps[f.name] = inp;
    } else if (f.type == "gps") {
      const div = document.createElement("div");
      const btn = document.createElement("button");
      btn.textContent = "GPS ON";
      const inp = document.createElement("input");
      inp.type = "text";
      inp.disabled = true;
      inp.style.fontSize = "18px";
      div.appendChild(btn);
      div.appendChild(inp);

      btn.onclick = () => {
        if (startGPS((latlng) => {
          if (latlng) {
            inp.value = latlng;
          } else {
            btn.disabled = false;
          }
        })) {
          btn.disabled = true;
        };
      };
      if (watchid) {
        btn.disabled = true;
        inp.value = latlng;
      }
      tbl.appendChild(div);
      comps[f.name] = inp;
    } else if (f.type == "datetime") {
      const inp = document.createElement("input");
      inp.type = "datetime-local";
      inp.style.fontSize = "18px";
      inp.value = new DateTime().toStringLocal();
      console.log(new DateTime().toStringLocal().replace("T", " "));
      tbl.appendChild(inp);
      comps[f.name] = inp;
    } else {
      throw new Error("not supported type: " + f.type);
    }
  }
  tbl.init = () => {

  };
  tbl.getValue = () => {
    const res = {};
    for (const f of fmt) {
      res[f.name] = comps[f.name].value;
    }
    return res;
  };
  tbl.setValue = (obj) => {
    for (const name in comps) {
      comps[name].value = "";
    }
    for (const name in obj) {
      comps[name].value = obj[name];
    }
  };
  return tbl;
};

const editor = makeFormated(fmt);
diveditor.appendChild(editor);

const getFirstLine = (s) => {
  const n = s.indexOf("\n");
  if (n < 0) return s;
  return s.substring(0, n);
};

const showList = () => {
  const filter = infilter.value;

  divlist.innerHTML = "";
  for (const item in memos) {
    const div = cr("div", divlist);
    if (filter) {
      const memo = memos[item];
      let flg = false;
      for (const name in memo) {
        if (memo[name].indexOf(filter) >= 0) {
          flg = true;
          break;
        }
      }
      if (!flg) continue;
    }
    //div.textContent = item; // 
    div.textContent = item; //getFirstLine(memos[item]) || item;
    div.onclick = () => {
      editor.setValue(memos[item]);
    };
  }
};

editor.onchange = e => {
  if (!currentmemo) {
    currentmemo = new DateTime().toString();
  }
  const obj = editor.getValue();
  if (obj) {
    memos[currentmemo] = obj;
  } else {
    delete memos[currentmemo];
  }
  showList();
  saveMemo();
};

btnnew.onclick = () => {
  currentmemo = null;
  editor.setValue({});
};

infilter.onchange = () => {
  showList();
};

showList();
</script>
